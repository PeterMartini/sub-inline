#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "lexicals.h"
#include "clone_op.h"

/*
 *    This file has the main components of the Sub::Inline plugin:
 *       * The BOOT section to register the inline keyword handler
 *       * inline_keyword_handler itself, which will do custom parsing
 *         up to the start of the code block and then hand it back to the Perl
 *         engine
 *       * A Perl_call_checker named inline_cv, which gets attached to any CV
 *         generated by the Perl engine after the 'inline sub' was declared
 */

static OP * inline_cv(pTHX_ OP *op, GV *namegv, SV* ckobj)
{
    const AV * details = (AV*)ckobj;
    const CV * const cv = (CV*)AvARRAY(details)[0];
    const unsigned int paramcount = SvIV(AvARRAY(details)[1]);
    OP *o = clone_op(aTHX_ CvROOT(cv));
    return o;
}

#define BUFPTR PL_parser->bufptr

static Perl_keyword_plugin_t old_plugin;
static int inline_keyword_handler(pTHX_ char *keyword_ptr, STRLEN keyword_len, OP **op_ptr)
{
    STRLEN namepos = 0;
    char name[sizeof PL_parser->tokenbuf];
    unsigned int paramcount = 0;

    if (keyword_len != strlen("inline") || memcmp(keyword_ptr, "inline", keyword_len))
        return old_plugin(aTHX_ keyword_ptr, keyword_len, op_ptr);

    /* ... sub ... */
    lex_read_space(0);
    if (*BUFPTR++ != 's' ||
        *BUFPTR++ != 'u' ||
        *BUFPTR++ != 'b' ||
        !isSPACE(BUFPTR[0]))
        return old_plugin(aTHX_ keyword_ptr, keyword_len, op_ptr);

    save_item(PL_subname);

    /* ... <name> ... */
    lex_read_space(0);
    if (!isALPHA_A(*BUFPTR)) {
        croak("Inline sub names must start with an ASCII letter");
    }
    while(isWORDCHAR_A(*BUFPTR) && namepos < sizeof PL_parser->tokenbuf){
        name[namepos++] = *BUFPTR++;
    }
    name[namepos] = '\0';
    sv_setpvn(PL_subname, name, namepos);

    const I32 floor = start_subparse(FALSE,0);

    /* ( '$' <name> ',' '$' <name> ) */
    lex_read_space(0);
    if (*BUFPTR++ != '(') {
        croak("Expected a signature for "SVf"\n", SVfARG(PL_subname));
    }

    lex_read_space(0);
    while (*BUFPTR && *BUFPTR != ')') {
        namepos = 0;
        name[namepos++] = *BUFPTR;

        /* For initial release / proof of concept only allowing scalars */
        if (*BUFPTR++ != '$') {
            if (BUFPTR[-1] == '@' || BUFPTR[-1] == '%') {
                croak("Sub::Inline currently only supports scalars.  If you'd like to see arrays and hashes, voice your support in the bug tracker so we can add test cases and make it happen!");
            } else {
                croak("Expected the name of a scalar variable");
            }
        }
        /* Allow spaces between the sigil and the name, like the core */
        lex_read_space(0);
        if (!isALPHA_A(*BUFPTR)){
            croak("Parameter names must start with an ASCII letter");
        }

        while (isWORDCHAR_A(*BUFPTR)) {
            name[namepos++] = *BUFPTR;
            BUFPTR++;
        }
        name[namepos] = '\0';

        /* Register the name */
        add_lexical(aTHX_ name);
        paramcount++;

        /* Next must be either a comma or a ')' */
        lex_read_space(0);
        if (*BUFPTR == ',') {
            BUFPTR++;
            lex_read_space(0);
        } else if (*BUFPTR != ')') {
            croak("Parse error: Expected a comma or parens after the parameter name");
        }
    }
    if (!*BUFPTR++) {
        croak("inline sub signature not terminated");
    }

    /* Check for and parse the block */
    lex_read_space(0);
    if (*BUFPTR == '{') {
        SvREFCNT_inc_simple_void(PL_compcv);
        SAVEFREESV(PL_compcv);
        OP* block = parse_block(0);
        OP* nameop = newSVOP(OP_CONST, 0, newSVsv(PL_subname));
        const CV* cv = newATTRSUB(floor, nameop, NULL, NULL, block);
        if (!cv) {
            return KEYWORD_PLUGIN_DECLINE;
        }
        OP* o = CvSTART(cv);
        while (o) {
            const SV * const errorsv = clone_check(o);
            if (errorsv)
                croak("%" SVf, SVfARG(errorsv));
            o = o->op_next;
        }
        /* XXX - This leaks, fix it! */
        AV * av = newAV();
        av_push(av, (SV*)cv); 
        av_push(av, newSViv(paramcount)); 
        cv_set_call_checker((CV*)cv, inline_cv, (SV*)av);
    } else {
        croak("Parse error: Expected a block after the inline sub declaration");
    }

    *op_ptr = NULL;
    return KEYWORD_PLUGIN_STMT;
}


/* vim:set ts=8 sts=4 et: */

MODULE = Sub::Inline                              PACKAGE = Sub::Inline

BOOT:
    old_plugin = PL_keyword_plugin;
    PL_keyword_plugin = inline_keyword_handler;
